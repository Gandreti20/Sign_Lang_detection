<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call with Sign Language Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .video-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .video-wrapper {
            width: 48%;
            position: relative;
        }
        video {
            width: 100%;
            border-radius: 8px;
            background-color: #000;
        }
        .controls {
            margin-bottom: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 20px;
            margin-right: 10px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        .translation {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
        }
        #roomInfo {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        .gesture-history {
            margin-top: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 200px;
            overflow-y: auto;
        }
        .gesture-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .gesture-item:last-child {
            border-bottom: none;
        }
        .gesture-time {
            color: #666;
            font-size: 12px;
        }
        .room-details {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .share-link {
            margin-top: 15px;
        }
        .share-link input {
            width: 80%;
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .room-details button {
            padding: 8px 16px;
            background: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <button id="createRoom">Create Room</button>
            <button id="joinRoom">Join Room</button>
            <input type="text" id="roomInput" placeholder="Enter Room ID">
            <button id="shareRoom" style="display: none;">Share Room Link</button>
        </div>
        
        <div id="roomInfo"></div>
        
        <div class="video-container">
            <div class="video-wrapper">
                <video id="localVideo" autoplay playsinline muted></video>
                <div class="translation" id="localTranslation"></div>
            </div>
            <div class="video-wrapper">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="translation" id="remoteTranslation"></div>
            </div>
        </div>

        <div class="gesture-history">
            <h3>Gesture History</h3>
            <div id="gestureList"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.scaledrone.com/scaledrone.min.js"></script>
    <script>
        // Configure server URL based on environment
        const SERVER_URL = 'https://sign-language-server-wzqf.onrender.com';
        
        const socket = io(SERVER_URL, {
            transports: ['polling'],
            reconnection: true,
            reconnectionAttempts: 10,
            reconnectionDelay: 1000,
            timeout: 60000,
            forceNew: false,
            autoConnect: true,
            path: '/socket.io'
        });
        let localStream;
        let peerConnection;
        let currentRoomId;

        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // Add these free TURN servers for better connectivity
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10
        };

        async function initializeMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                document.getElementById('localVideo').srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices:', error);
            }
        }

        function createPeerConnection() {
            try {
                console.log('Creating new RTCPeerConnection');
                peerConnection = new RTCPeerConnection(configuration);
                
                // Add local stream tracks to the connection
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        console.log(`Adding local ${track.kind} track to peer connection`);
                        peerConnection.addTrack(track, localStream);
                    });
                } else {
                    console.warn('Local stream not available when creating peer connection');
                }

                // Handle incoming tracks
                peerConnection.ontrack = event => {
                    console.log(`Received remote ${event.track.kind} track`);
                    const remoteVideo = document.getElementById('remoteVideo');
                    if (remoteVideo.srcObject !== event.streams[0]) {
                        console.log('Setting remote video stream');
                        remoteVideo.srcObject = event.streams[0];
                        
                        // Call the new function to set up everything when connection is established
                        onConnectionEstablished();
                        
                        // Update UI to show connection is successful and add end meeting button
                        document.getElementById('roomInfo').innerHTML = `
                            <div class="room-details">
                                <h3>Connected! üéâ</h3>
                                <p>Room ID: <strong>${currentRoomId}</strong></p>
                                <div class="alert" style="background-color: #d4edda; padding: 10px; border-radius: 4px; margin: 10px 0;">
                                    <p><strong>Connection successful!</strong></p>
                                    <p>You are now connected with the other participant.</p>
                                    <p>Sign language gestures will be detected and displayed automatically.</p>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                                    ${isRoomCreator() ? `
                                    <button onclick="createAndSendOffer()" style="background: #007bff;">
                                        Reconnect if Needed
                                    </button>
                                    ` : ''}
                                    <button onclick="endMeeting()" style="background: #dc3545;">
                                        End Meeting
                                    </button>
                                </div>
                                <div style="margin-top: 15px;">
                                    <button onclick="restartGestureRecognition()" style="background: #28a745;">
                                        Restart Gesture Recognition
                                    </button>
                                </div>
                            </div>
                        `;
                        
                        // Clear any request offer interval
                        if (window.requestOfferInterval) {
                            clearInterval(window.requestOfferInterval);
                        }
                    }
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        console.log('Generated local ICE candidate');
                        
                        // Send the candidate via Scaledrone
                            sendSignalingMessage({
                                type: 'candidate',
                                candidate: event.candidate
                            });
                        } else {
                        console.log('ICE candidate generation complete');
                    }
                };
                
                // Log connection state changes and update UI
                peerConnection.oniceconnectionstatechange = () => {
                    const state = peerConnection.iceConnectionState;
                    console.log('ICE connection state changed to:', state);
                    
                    // Update the connection status display
                    updateConnectionStatus(state);
                    
                    // Handle specific states
                    if (state === 'connected' || state === 'completed') {
                        console.log('Connection established successfully');
                        
                        // Clear any intervals
                        if (window.requestOfferInterval) {
                            clearInterval(window.requestOfferInterval);
                        }
                        if (window.offerInterval) {
                            clearInterval(window.offerInterval);
                        }
                    } else if (state === 'failed') {
                        console.error('Connection failed');
                        
                        // If we're the creator, try to send a new offer after a delay
                        if (isRoomCreator()) {
                            setTimeout(() => {
                                console.log('Attempting to recover from failed connection');
                                createAndSendOffer();
                            }, 2000);
                        }
                    }
                };
                
                return peerConnection;
            } catch (error) {
                console.error('Error creating peer connection:', error);
                return null;
            }
        }

        // Improved server availability check
        async function checkServerAvailability() {
            try {
                console.log('Checking server availability...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(`${SERVER_URL}/health`, {
                    signal: controller.signal,
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Server health check passed:', data);
                    return true;
                }
                
                console.error('‚ùå Server health check failed with status:', response.status);
                return false;
            } catch (error) {
                console.error('‚ùå Server availability check error:', error.message);
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Server Unavailable</h3>
                        <p>${error.name === 'AbortError' ? 'Server request timed out' : error.message}</p>
                        <button onclick="checkServerAvailability()" style="background: #dc3545;">Try Again</button>
                    </div>
                `;
                return false;
            }
        }

        // Enhanced connection logging
        socket.on('connect', () => {
            console.log('‚úÖ Connected to server with ID:', socket.id);
            console.log('‚úÖ Transport method:', socket.io.engine.transport.name);
            console.log('‚úÖ Connection state:', socket.connected ? 'connected' : 'disconnected');
            
            // Verify connection is working
            socket.emit('ping');
        });

        socket.on('pong', () => {
            console.log('‚úÖ Received pong from server - connection is working');
        });

        // Add this function to check if we're using a local room
        function isUsingLocalRoom() {
            return currentRoomId && !currentRoomId.includes('-');
        }

        // Update the socket connection error handler
        socket.on('connect_error', (error) => {
            console.error('‚ùå Socket connection error:', error.message);
            
            // If we're using a local room, don't show the error
            if (isUsingLocalRoom()) {
                console.log("Using local room - ignoring socket connection errors");
                return;
            }
            
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details" style="color: red;">
                    <h3>Connection Error</h3>
                    <p>Failed to connect to server: ${error.message}</p>
                    <button onclick="reconnectSocket()" style="background: #dc3545;">Reconnect</button>
                    <button onclick="createLocalRoom()" style="background: #28a745; margin-left: 10px;">Use Local Room</button>
                </div>
            `;
        });

        // Update the socket disconnect handler
        socket.on('disconnect', (reason) => {
            console.error('‚ùå Socket disconnected:', reason);
            
            // If we're using a local room, don't try to reconnect
            if (isUsingLocalRoom()) {
                console.log("Using local room - not attempting reconnection");
                socket.disconnect(); // Explicitly disconnect to prevent auto-reconnect
            }
        });

        // Add this debugging code right after the socket connection setup
        socket.on('ping', () => {
            console.log('‚úÖ Received pong from server - connection is working');
            // Test emitting a simple event to verify bidirectional communication
            socket.emit('test-event', { message: 'Testing event emission' });
        });

        // Add this to the server to verify event reception
        socket.on('test-event', (data) => {
            console.log('‚úÖ Test event received:', data);
            // Respond to confirm the server can emit back
            emit('test-response', { received: true });
        });

        // Add this to verify server responses
        socket.on('test-response', (data) => {
            console.log('‚úÖ Server responded to test event:', data);
        });

        // Add this function before the createRoom event handler
        async function isServerReachable() {
            try {
                console.log("Testing basic server reachability...");
                const response = await fetch(`${SERVER_URL}/health`, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: {
                        'Accept': 'application/json'
                    },
                    timeout: 5000
                });
                
                if (response.ok) {
                    console.log("‚úÖ Server is reachable");
                    return true;
                } else {
                    console.error("‚ùå Server returned status:", response.status);
                    return false;
                }
            } catch (error) {
                console.error("‚ùå Server is not reachable:", error.message);
                return false;
            }
        }

        // Update the create room event handler
        document.getElementById('createRoom').addEventListener('click', async () => {
            console.log("üîò Create Room button clicked - event handler triggered");
            
            // Show loading state immediately
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Initializing...</h3>
                    <p>Checking server availability...</p>
                </div>
            `;
            
            try {
                // First check if server is reachable at all
                const serverReachable = await isServerReachable().catch(() => false);
                
                // Initialize media first to avoid delays later
                console.log("Initializing media...");
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details">
                        <h3>Initializing Media...</h3>
                        <p>Please allow camera and microphone access...</p>
                    </div>
                `;
                
                await initializeMedia();
                console.log("Media initialized successfully");
                
                if (serverReachable) {
                    // If socket is not connected, try to connect with shorter timeout
                    if (!socket.connected) {
                        console.log("Socket not connected, attempting to connect...");
                        
                        // Force a new connection attempt
                        socket.disconnect();
                        socket.connect();
                        
                        // Wait for connection with a shorter timeout
                        try {
                            await new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => {
                                    socket.off('connect');
                                    reject(new Error('Socket connection timed out after 5 seconds'));
                                }, 5000); // Reduce timeout to 5 seconds
                                
                                socket.once('connect', () => {
                                    clearTimeout(timeout);
                                    console.log("‚úÖ Socket connected successfully");
                                    resolve();
                                });
                            });
                            
                            // Show room creation state
                            document.getElementById('roomInfo').innerHTML = `
                                <div class="room-details">
                                    <h3>Creating Room...</h3>
                                    <p>Connecting to server and creating your room...</p>
                                </div>
                            `;
                            
                            console.log("Creating room...");
                            createRoom();
                        } catch (error) {
                            console.log("Socket connection timed out, falling back to local room");
                            createLocalRoom();
                        }
                    } else {
                        // Socket already connected
                        document.getElementById('roomInfo').innerHTML = `
                            <div class="room-details">
                                <h3>Creating Room...</h3>
                                <p>Connecting to server and creating your room...</p>
                            </div>
                        `;
                        
                        console.log("Creating room...");
                        createRoom();
                    }
                } else {
                    // Server not reachable, use local room
                    console.log("Server not reachable, using local room");
                    createLocalRoom();
                }
            } catch (error) {
                console.error("Error in room creation setup:", error);
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Connection Error</h3>
                        <p>${error.message}</p>
                        <p>Falling back to local room mode.</p>
                        <button onclick="createLocalRoom()" style="background: #28a745;">Create Local Room</button>
                    </div>
                `;
            }
        });

        // Modify the createRoom function to use a simpler approach
        function createRoom() {
            console.log("Setting up room creation listeners...");
            
            // Clear any existing listeners
            socket.off('room-created');
            socket.off('error');
            
            // Set up a timeout for the entire process
            const timeout = setTimeout(() => {
                console.log("Room creation timed out");
                socket.off('room-created');
                socket.off('error');
                
                // Try alternative method
                console.log("Trying alternative room creation method...");
                tryAlternativeRoomCreation();
            }, 10000);

            // Set up event listeners
            socket.once('room-created', (data) => {
                console.log('Room created event received:', data);
                clearTimeout(timeout);
                
                if (!data || !data.roomId) {
                    document.getElementById('roomInfo').innerHTML = `
                        <div class="room-details" style="color: red;">
                            <h3>Invalid Room Data</h3>
                            <p>The server returned invalid room data.</p>
                            <button onclick="retryCreateRoom()" style="background: #dc3545;">Try Again</button>
                        </div>
                    `;
                    return;
                }
                
                handleRoomCreated(data);
            });

            socket.once('error', (error) => {
                console.error('Error event received:', error);
                clearTimeout(timeout);
                
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Room Creation Error</h3>
                        <p>${error.message || 'An unknown error occurred'}</p>
                        <button onclick="retryCreateRoom()" style="background: #dc3545;">Try Again</button>
                    </div>
                `;
            });

            // Simple emit without acknowledgment
            console.log("Emitting create-room event to server...");
            socket.emit('create-room');
        }

        // Handle successful room creation
        function handleRoomCreated(data) {
            console.log("Handling successful room creation:", data);
            currentRoomId = data.roomId;
            const roomLink = `${window.location.origin}/Sign_Lang_detection?room=${data.roomId}`;
            
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Room Created Successfully! üéâ</h3>
                    <p>Room ID: <strong>${data.roomId}</strong></p>
                    <div class="share-link">
                        <p><strong>Share this link:</strong></p>
                        <div style="display: flex; gap: 10px; margin: 10px 0;">
                            <input type="text" value="${roomLink}" readonly id="roomLink" 
                                   style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <button onclick="copyRoomLink()" class="copy-button" 
                                    style="background: #28a745;">Copy Link</button>
                        </div>
                    </div>
                </div>
            `;

            // Create peer connection
            createPeerConnection();
            console.log("Peer connection created successfully");
        }

        document.getElementById('joinRoom').addEventListener('click', async () => {
            const roomId = document.getElementById('roomInput').value;
            if (!roomId) {
                alert("Please enter a Room ID");
                return;
            }
            
            // Show joining state
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Joining Room...</h3>
                    <p>Connecting to room ${roomId}...</p>
                </div>
            `;
            
            try {
                // Initialize media
                await initializeMedia();
                
                // Check if server is available
                const serverAvailable = await isServerReachable().catch(() => false);
                
                if (serverAvailable && socket.connected) {
                    // Join via server
                    currentRoomId = roomId;
                    socket.emit('join-room', { roomId });
                    console.log("Joining room via server:", roomId);
                } else {
                    // Join locally
                    console.log("Server unavailable, joining room locally");
                    joinLocalRoom(roomId);
                }
            } catch (error) {
                console.error("Error joining room:", error);
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Error Joining Room</h3>
                        <p>${error.message}</p>
                        <button onclick="window.location.reload()" style="background: #dc3545;">Try Again</button>
                    </div>
                `;
            }
        });

        socket.on('offer', async data => {
            createPeerConnection();
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('answer', { answer, roomId: data.roomId });
        });

        socket.on('answer', async data => {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        });

        socket.on('ice-candidate', async data => {
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data));
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        });

        socket.on('gesture-detected', data => {
            const translationElement = data.userId === socket.id ? 
                document.getElementById('localTranslation') : 
                document.getElementById('remoteTranslation');
            
            translationElement.textContent = data.gesture.translation;
            
            // Share the gesture with the other participant
            if (data.userId === socket.id) {
                shareGestureDetection(data.gesture.translation);
            }
            
            setTimeout(() => {
                translationElement.textContent = '';
            }, 3000);

            // Add to gesture history
            addGestureToHistory(data);
        });

        socket.on('gesture-history', data => {
            const gestureList = document.getElementById('gestureList');
            gestureList.innerHTML = '';
            
            data.gestures.forEach(gesture => {
                addGestureToHistory(gesture);
            });
        });

        function addGestureToHistory(gestureData) {
            const gestureList = document.getElementById('gestureList');
            const gestureItem = document.createElement('div');
            gestureItem.className = 'gesture-item';
            
            const time = new Date(gestureData.timestamp).toLocaleTimeString();
            const isLocal = gestureData.userId === socket.id;
            
            gestureItem.innerHTML = `
                <span>${isLocal ? 'You' : 'Remote User'}: ${gestureData.gesture.translation}</span>
                <span class="gesture-time">${time}</span>
            `;
            
            gestureList.insertBefore(gestureItem, gestureList.firstChild);
        }

        // Update the sendFrameForDetection function to check if using a local room
        function sendFrameForDetection(video) {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // Store the interval ID so we can clear it if needed
            const frameInterval = setInterval(() => {
                // Check if we have a room ID and if socket is connected
                if (!currentRoomId) return;
                
                // Check if this is a local room (starts with a specific prefix or pattern)
                const isLocalRoom = !socket.connected || currentRoomId.length === 8;
                
                // If it's a local room, don't try to send frames
                if (isLocalRoom) {
                    console.log("Using local room - gesture detection disabled");
                    return;
                }
                
                // Only send frames if socket is connected
                if (!socket.connected) {
                    console.log("Socket disconnected - pausing frame sending");
                    return;
                }
                
                try {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const frame = canvas.toDataURL('image/jpeg', 0.5);
                    socket.emit('gesture-frame', { 
                        frame,
                        roomId: currentRoomId
                    });
                } catch (error) {
                    console.error("Error sending frame:", error);
                }
            }, 100); // Send frame every 100ms
            
            // Store the interval ID on the window object so we can clear it later if needed
            window.frameDetectionInterval = frameInterval;
            
            // Add a function to stop frame detection
            window.stopFrameDetection = function() {
                if (window.frameDetectionInterval) {
                    clearInterval(window.frameDetectionInterval);
                    console.log("Frame detection stopped");
                }
            };
        }

        document.getElementById('localVideo').addEventListener('play', function() {
            sendFrameForDetection(this);
        });

        // Update the window load handler
        window.onload = async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room');
            
            if (roomId) {
                console.log("Found room ID in URL:", roomId);
                document.getElementById('roomInput').value = roomId;
                
                // Auto-join the room after a short delay
                setTimeout(async () => {
                    try {
                        // Initialize media
                        await initializeMedia();
                        
                        // Check if server is available
                        const serverAvailable = await isServerReachable().catch(() => false);
                        
                        if (serverAvailable && socket.connected) {
                            // Join via server
                            currentRoomId = roomId;
                            socket.emit('join-room', { roomId });
                            console.log("Auto-joining room via server:", roomId);
                        } else {
                            // Join locally
                            console.log("Server unavailable, auto-joining room locally");
                            joinLocalRoom(roomId);
                        }
                    } catch (error) {
                        console.error("Error auto-joining room:", error);
                        document.getElementById('roomInfo').innerHTML = `
                            <div class="room-details" style="color: red;">
                                <h3>Error Joining Room</h3>
                                <p>${error.message}</p>
                                <button onclick="window.location.reload()" style="background: #dc3545;">Try Again</button>
                            </div>
                        `;
                    }
                }, 1000);
            }
        };

        // Add this function for copying the room link if it doesn't exist
        function copyRoomLink() {
            const roomLink = document.getElementById('roomLink');
            roomLink.select();
            roomLink.setSelectionRange(0, 99999); // For mobile devices
            
            try {
                const successful = document.execCommand('copy');
                
                // Show success message
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied! ‚úì';
                button.style.backgroundColor = '#218838';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '#28a745';
                }, 2000);
                
                console.log('Copy successful:', successful);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy link. Please copy it manually.');
            }
        }

        // Update the retryCreateRoom function to fall back to local room faster
        function retryCreateRoom() {
            console.log("Retrying room creation...");
            
            // Reset any error states
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Reconnecting...</h3>
                    <p>Attempting to reconnect to server...</p>
                </div>
            `;
            
            // Check socket connection
            if (!socket.connected) {
                console.log("Socket not connected, trying local room creation...");
                createLocalRoom();
            } else {
                console.log("Socket connected, trying alternative room creation...");
                tryAlternativeRoomCreation();
            }
        }

        // Add reconnect function
        function reconnectSocket() {
            console.log('Attempting to reconnect socket...');
            socket.connect();
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Reconnecting...</h3>
                    <p>Attempting to connect to server...</p>
                </div>
            `;
        }

        // Add connection attempt logging
        console.log("Attempting to connect to server at:", SERVER_URL);

        // Add this function to try alternative connection methods
        function tryAlternativeConnection() {
            console.log("Trying alternative connection method...");
            
            // Create a new socket with minimal options
            const alternativeSocket = io(SERVER_URL, {
                transports: ['polling'],
                reconnection: false,
                timeout: 10000
            });
            
            alternativeSocket.on('connect', () => {
                console.log("‚úÖ Alternative connection successful");
                alternativeSocket.disconnect();
                
                // Try reconnecting the main socket
                socket.disconnect();
                setTimeout(() => {
                    socket.connect();
                }, 1000);
            });
            
            alternativeSocket.on('connect_error', (error) => {
                console.error("‚ùå Alternative connection failed:", error.message);
                alternativeSocket.disconnect();
            });
            
            // Disconnect after 10 seconds regardless
            setTimeout(() => {
                if (alternativeSocket.connected) {
                    alternativeSocket.disconnect();
                }
            }, 10000);
        }

        // Update the alternative room creation method
        function tryAlternativeRoomCreation() {
            console.log("Trying alternative room creation method...");
            
            // Try simple socket event first
            trySimpleSocketRoomCreation();
        }

        // Add this function for simple socket room creation
        function trySimpleSocketRoomCreation() {
            console.log("Attempting to create room via simple socket event...");
            
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Creating Room (Alternative Method)...</h3>
                    <p>Trying simplified approach...</p>
                </div>
            `;
            
            // Clear any existing listeners
            socket.off('simple-room-created');
            socket.off('error');
            
            // Set up a timeout
            const timeout = setTimeout(() => {
                console.log("Simple room creation timed out");
                socket.off('simple-room-created');
                socket.off('error');
                
                // Try HTTP fallback as last resort
                createRoomViaHttp();
            }, 10000);
            
            // Set up event listeners
            socket.once('simple-room-created', (data) => {
                console.log('Simple room created event received:', data);
                clearTimeout(timeout);
                
                if (!data || !data.roomId) {
                    document.getElementById('roomInfo').innerHTML = `
                        <div class="room-details" style="color: red;">
                            <h3>Invalid Room Data</h3>
                            <p>The server returned invalid room data.</p>
                            <button onclick="retryCreateRoom()" style="background: #dc3545;">Try Again</button>
                        </div>
                    `;
                    return;
                }
                
                handleRoomCreated(data);
            });
            
            socket.once('error', (error) => {
                console.error('Error event received:', error);
                clearTimeout(timeout);
                
                // Try HTTP fallback
                createRoomViaHttp();
            });
            
            // Emit simple event
            console.log("Emitting simple-create-room event...");
            socket.emit('simple-create-room');
        }

        // Update the HTTP fallback function
        async function createRoomViaHttp() {
            console.log("Attempting to create room via HTTP fallback...");
            
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Creating Room (HTTP Fallback)...</h3>
                    <p>Waiting for server response...</p>
                </div>
            `;
            
            try {
                const response = await fetch(`${SERVER_URL}/create-room`, {
                    method: 'POST',
                    mode: 'cors', // Explicitly set CORS mode
                    credentials: 'omit', // Don't send cookies
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        clientId: socket.id || 'unknown'
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log("Room created via HTTP:", data);
                
                if (data.success && data.roomId) {
                    // Manually join the room via socket
                    socket.emit('join-room', { roomId: data.roomId });
                    
                    // Handle room creation success
                    handleRoomCreated(data);
                } else {
                    throw new Error(data.error || 'Unknown error');
                }
            } catch (error) {
                console.error("HTTP room creation failed:", error);
                
                // Final fallback - generate a room ID locally
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    console.log("CORS issue detected, using local room ID generation as last resort");
                    createLocalRoom();
                } else {
                    document.getElementById('roomInfo').innerHTML = `
                        <div class="room-details" style="color: red;">
                            <h3>Room Creation Failed</h3>
                            <p>${error.message}</p>
                            <button onclick="retryCreateRoom()" style="background: #dc3545;">Try Again</button>
                        </div>
                    `;
                }
            }
        }

        // Update the createLocalRoom function to add a manual connection button
        function createLocalRoom() {
            console.log('Creating new room with Scaledrone signaling');
            
            // Set a flag to indicate we're the room creator
            window.isCreator = true;
            
            // Generate a random room ID
            const roomId = Math.random().toString(36).substring(2, 10);
            
            // Create a proper shareable URL using the actual deployed GitHub Pages URL
            const baseUrl = 'https://gandreti20.github.io/Sign_Lang_detection/';
            const roomUrl = `${baseUrl}?room=${roomId}`;
            
            // Create a QR code for easy mobile access
            const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(roomUrl)}`;
            
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Creating Room...</h3>
                    <p>Room ID: <strong>${roomId}</strong></p>
                    <p>Setting up signaling service...</p>
                </div>
            `;
            
            // Set current room ID
            currentRoomId = roomId;
            
            // Initialize the peer connection and signaling
            initializeMedia().then(() => {
                setupLocalPeerConnection().then(() => {
                    // Update UI with room details
                    document.getElementById('roomInfo').innerHTML = `
                        <div class="room-details">
                            <h3>Room Created! üéâ</h3>
                    <p>Room ID: <strong>${roomId}</strong></p>
                    <div class="alert" style="background-color: #d4edda; padding: 10px; border-radius: 4px; margin: 10px 0;">
                        <p><strong>Success:</strong> Your room is ready to share!</p>
                                <p>Share the link or room ID with others to join.</p>
                    </div>
                    <div class="share-link">
                        <p><strong>Share this link with others:</strong></p>
                        <div style="display: flex; gap: 10px; margin: 10px 0;">
                            <input type="text" value="${roomUrl}" 
                                   readonly id="roomLink" 
                                   style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <button onclick="copyRoomLink()" class="copy-button" 
                                    style="background: #28a745;">Copy Link</button>
                        </div>
                    </div>
                    <div style="text-align: center; margin: 15px 0;">
                        <p><strong>Or scan this QR code to join:</strong></p>
                        <img src="${qrCodeUrl}" alt="Room QR Code" style="max-width: 150px; margin: 10px auto;">
                    </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <button onclick="createAndSendOffer()" style="background: #007bff;">
                                    Send Connection Offer Manually
                                </button>
                            </div>
                </div>
            `;
            
            // Disable frame sending to server
            window.stopFrameDetection && window.stopFrameDetection();
            
            // Make the room joinable
            document.getElementById('shareRoom').style.display = 'inline-block';
                }).catch(error => {
                    console.error('Error setting up peer connection:', error);
                    
                    document.getElementById('roomInfo').innerHTML = `
                        <div class="room-details" style="color: red;">
                            <h3>Room Creation Error</h3>
                            <p>Failed to set up signaling: ${error.message}</p>
                            <button onclick="window.location.reload()" style="background: #dc3545;">Try Again</button>
                        </div>
                    `;
                });
            }).catch(error => {
                console.error('Error initializing media:', error);
                
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Media Access Error</h3>
                        <p>Failed to access camera/microphone: ${error.message}</p>
                        <p>Please ensure you have granted permission to use your camera and microphone.</p>
                        <button onclick="window.location.reload()" style="background: #dc3545;">Try Again</button>
                    </div>
                `;
            });
        }

        // Update the setupPublicSignaling function
        function setupPublicSignaling(roomId) {
            return new Promise((resolve, reject) => {
                console.log("Setting up Scaledrone signaling for room:", roomId);
                
                // Create a new Scaledrone instance with your channel ID
            const drone = new ScaleDrone('Xw9M4ArOLsh59WOa'); 
            
                // Handle connection opening
            drone.on('open', error => {
                if (error) {
                        console.error('Error connecting to Scaledrone:', error);
                        reject(error);
                    return;
                }
                
                    console.log('Connected to Scaledrone with client ID:', drone.clientId);
                    
                    // Subscribe to the room
                    const roomName = `observable-${roomId}`;
                    const room = drone.subscribe(roomName);
                
                room.on('open', error => {
                    if (error) {
                        console.error('Error opening room:', error);
                            reject(error);
                        return;
                    }
                        console.log(`Successfully joined Scaledrone room: ${roomName}`);
                        
                        // Store room and drone for later use
                        window.signalRoom = room;
                        window.signalingDrone = drone;
                        
                        // Set up message handling
                room.on('data', message => {
                            console.log('Received message from Scaledrone:', message);
                            
                            // Ignore messages from ourselves
                            if (message.clientId === drone.clientId) {
                                console.log('Ignoring message from self');
                                return;
                            }
                            
                            // Process the message based on its type
                        if (message.type === 'offer') {
                                console.log('Received offer from peer');
                            handleRemoteOffer(message.offer);
                        } else if (message.type === 'answer') {
                                console.log('Received answer from peer');
                            handleRemoteAnswer(message.answer);
                        } else if (message.type === 'candidate') {
                                console.log('Received ICE candidate from peer');
                            handleRemoteCandidate(message.candidate);
                            } else if (message.type === 'join-notification') {
                                console.log('Someone joined the room:', message.clientId);
                                // If we're the room creator, send an offer to the new participant
                                if (isRoomCreator()) {
                                    console.log('We are the room creator, sending offer to new participant');
                                    createAndSendOffer();
                                }
                            } else if (message.type === 'request-offer') {
                                console.log('Received request for offer');
                                // If we're the room creator, send an offer
                                if (isRoomCreator()) {
                                    console.log('We are the room creator, sending offer in response to request');
                                    createAndSendOffer();
                                }
                            } else if (message.type === 'presence') {
                                console.log('Received presence notification from:', message.clientId);
                                // If we're not the creator and we just joined, request an offer
                                if (!isRoomCreator() && !window.offerRequested) {
                                    window.offerRequested = true;
                                    setTimeout(() => {
                                        announcePresenceAndRequestOffer();
                                    }, 1000); // Wait a second before requesting an offer
                                }
                            } else if (message.type === 'gesture-detected') {
                                console.log('Received gesture detection from peer:', message.gesture);
                                // Display the gesture on the remote video
                                displayRemoteGesture(message.gesture);
                            }
                        });
                        
                        // Announce our presence in the room
                        sendSignalingMessage({
                            type: 'presence',
                            message: 'Participant active in room'
                        });
                        
                        // If we're joining (not creating), request an offer after a short delay
                        if (!isRoomCreator()) {
                            setTimeout(() => {
                                announcePresenceAndRequestOffer();
                            }, 2000); // Wait 2 seconds before requesting an offer
                        }
                        
                        resolve(drone);
                    });
                });
                
                drone.on('error', error => {
                    console.error('Scaledrone connection error:', error);
                    reject(error);
                });
            });
        }

        // Add this function to check if we're the room creator
        function isRoomCreator() {
            // If we created the room, we'll have a flag set
            return window.isCreator === true;
        }

        // Improve the createAndSendOffer function
        async function createAndSendOffer() {
            try {
                console.log('Creating new offer to send to participant');
                
                // Make sure we have a peer connection
                if (!peerConnection) {
                    console.log('Creating peer connection before sending offer');
                    createPeerConnection();
                }
                
                // Reset the connection if it's in a failed state
                if (peerConnection.iceConnectionState === 'failed' || 
                    peerConnection.iceConnectionState === 'disconnected' ||
                    peerConnection.iceConnectionState === 'closed') {
                    console.log('Resetting peer connection before creating new offer');
                    peerConnection.close();
                    createPeerConnection();
                }
                
                // Create an offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await peerConnection.setLocalDescription(offer);
                console.log('Local description (offer) set successfully');
                
                // Send the offer via Scaledrone
                sendSignalingMessage({
                    type: 'offer',
                    offer: offer
                });
                
                console.log('New offer sent via Scaledrone');
                
                // Update UI to show offer was sent
                const statusElement = document.getElementById('offerStatus');
                if (statusElement) {
                    statusElement.textContent = 'Offer sent at ' + new Date().toLocaleTimeString();
                } else {
                    const roomInfo = document.querySelector('.room-details');
                    if (roomInfo) {
                        const statusDiv = document.createElement('div');
                        statusDiv.id = 'offerStatus';
                        statusDiv.style.marginTop = '10px';
                        statusDiv.style.color = '#28a745';
                        statusDiv.textContent = 'Offer sent at ' + new Date().toLocaleTimeString();
                        roomInfo.appendChild(statusDiv);
                    }
                }
            } catch (error) {
                console.error('Error creating and sending offer:', error);
                alert('Error sending offer: ' + error.message);
            }
        }

        // Fix the sendSignalingMessage function
        function sendSignalingMessage(message) {
            if (!window.signalingDrone) {
                console.error('Cannot send message: Scaledrone not initialized');
                return;
            }
            
            // Add client ID to the message
            const enhancedMessage = {
                ...message,
                clientId: window.signalingDrone.clientId,
                timestamp: Date.now()
            };
            
            console.log('Sending message via Scaledrone:', enhancedMessage);
            
            // Publish the message to the room
                window.signalingDrone.publish({
                    room: `observable-${currentRoomId}`,
                message: enhancedMessage
                });
        }

        // Fix the setupLocalPeerConnection function - REPLACE both implementations with this one
        async function setupLocalPeerConnection() {
            console.log('Setting up local peer connection as room creator');
            
            try {
                // Create peer connection if it doesn't exist
            if (!peerConnection) {
                createPeerConnection();
            }
            
                // Set up Scaledrone signaling
            await setupPublicSignaling(currentRoomId);
                console.log('Scaledrone signaling set up successfully');
            
                // Create an offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await peerConnection.setLocalDescription(offer);
                console.log('Local description (offer) set successfully');
                
                // Send the offer via Scaledrone
                sendSignalingMessage({
                    type: 'offer',
                    offer: offer
                });
                
                console.log('Offer sent via Scaledrone');
                
                // Set up a periodic check to resend the offer if needed
                window.offerInterval = setInterval(() => {
                    // If we have room members and we're the creator, check if we need to resend the offer
                    if (window.roomMembers && window.roomMembers.length > 1 && isRoomCreator()) {
                        console.log('Checking if we need to resend offer...');
                        // Only resend if we don't have a remote connection yet
                        if (peerConnection.iceConnectionState === 'new' || 
                            peerConnection.iceConnectionState === 'checking') {
                            console.log('Connection not established yet, resending offer');
                            createAndSendOffer();
                        } else {
                            console.log('Connection already established, no need to resend offer');
                            clearInterval(window.offerInterval);
                        }
                    }
                }, 5000); // Check every 5 seconds
            } catch (error) {
                console.error('Error setting up local peer connection:', error);
                
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Connection Error</h3>
                        <p>Failed to set up connection: ${error.message}</p>
                        <button onclick="window.location.reload()" style="background: #dc3545;">Try Again</button>
                    </div>
                `;
            }
        }

        // Fix the handler functions
        async function handleRemoteOffer(offer) {
            console.log('Processing remote offer');
            
            try {
                // Create peer connection if it doesn't exist
                if (!peerConnection) {
                    createPeerConnection();
                }
                
                // Set the remote description
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log('Remote description set successfully');
                
                // Create an answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Local description (answer) set successfully');
                
                // Send the answer
                sendSignalingMessage({
                    type: 'answer',
                    answer: answer
                });
                
                // Update UI to show connection is in progress
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details">
                        <h3>Connecting to Room...</h3>
                        <p>Room ID: <strong>${currentRoomId}</strong></p>
                        <p>Connection in progress. Please wait...</p>
                    </div>
                `;
            } catch (error) {
                console.error('Error handling remote offer:', error);
                
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Connection Error</h3>
                        <p>Failed to process connection offer: ${error.message}</p>
                        <button onclick="window.location.reload()" style="background: #dc3545;">Try Again</button>
                    </div>
                `;
            }
        }

        async function handleRemoteAnswer(answer) {
            console.log('Processing remote answer');
            
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                console.log('Remote description (answer) set successfully');
            } catch (error) {
                console.error('Error handling remote answer:', error);
            }
        }

        async function handleRemoteCandidate(candidate) {
            if (!peerConnection) {
                console.warn('Received ICE candidate but peer connection not created yet');
                return;
            }
            
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log('Added remote ICE candidate successfully');
            } catch (error) {
                console.error('Error adding remote ICE candidate:', error);
            }
        }

        // Update the joinLocalRoom function
        async function joinLocalRoom(roomId) {
            console.log('Joining room:', roomId);
            
            try {
                // Set flag to indicate we're NOT the room creator
                window.isCreator = false;
                
                // Initialize media if not already done
                if (!localStream) {
                    await initializeMedia();
                }
                
                // Set current room ID
                currentRoomId = roomId;
                
                // Show waiting message
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: orange;">
                        <h3>Joining Room...</h3>
                        <p>Room ID: <strong>${roomId}</strong></p>
                        <p>Connecting to signaling service...</p>
                    </div>
                `;
                
                // Create peer connection
                createPeerConnection();
                
                // Set up Scaledrone signaling
                await setupPublicSignaling(roomId);
                
                // Update UI to show waiting for offer
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: orange;">
                        <h3>Waiting for Room Creator</h3>
                        <p>Room ID: <strong>${roomId}</strong></p>
                        <p>Connected to signaling service. Waiting for the room creator...</p>
                        <p>This may take a moment. Please keep this tab open.</p>
                        <button onclick="announcePresenceAndRequestOffer()" style="background: #007bff;">Request Connection</button>
                    </div>
                `;
                
                console.log('Joined room with Scaledrone signaling, waiting for offer');
            } catch (error) {
                console.error('Error joining room:', error);
                
                document.getElementById('roomInfo').innerHTML = `
                    <div class="room-details" style="color: red;">
                        <h3>Error Joining Room</h3>
                        <p>${error.message}</p>
                        <button onclick="window.location.reload()" style="background: #dc3545;">Try Again</button>
                    </div>
                `;
            }
        }

        // Add this function to update the connection status display
        function updateConnectionStatus(state) {
            const connectionStatus = document.getElementById('connectionStatus');
            if (!connectionStatus) {
                const statusDiv = document.createElement('div');
                statusDiv.id = 'connectionStatus';
                statusDiv.style.padding = '10px';
                statusDiv.style.marginTop = '15px';
                statusDiv.style.borderRadius = '4px';
                
                const roomInfo = document.querySelector('.room-details');
                if (roomInfo) {
                    roomInfo.appendChild(statusDiv);
                }
            }
            
            const statusElement = document.getElementById('connectionStatus');
            if (statusElement) {
                let color = '#f8d7da'; // Red background
                let textColor = '#721c24'; // Red text
                let message = 'Disconnected';
                
                switch (state) {
                    case 'new':
                        color = '#fff3cd'; // Yellow background
                        textColor = '#856404'; // Yellow text
                        message = 'Connection setup in progress...';
                        break;
                    case 'checking':
                        color = '#fff3cd'; // Yellow background
                        textColor = '#856404'; // Yellow text
                        message = 'Checking connection...';
                        break;
                    case 'connected':
                    case 'completed':
                        color = '#d4edda'; // Green background
                        textColor = '#155724'; // Green text
                        message = 'Connected successfully!';
                        break;
                    case 'disconnected':
                        message = 'Connection temporarily disconnected. Trying to reconnect...';
                        break;
                    case 'failed':
                        message = 'Connection failed. Please try again.';
                        break;
                    case 'closed':
                        message = 'Connection closed.';
                        break;
                }
                
                statusElement.style.backgroundColor = color;
                statusElement.style.color = textColor;
                statusElement.innerHTML = `
                    <strong>Connection Status:</strong> ${message}
                    <div style="font-size: 12px; margin-top: 5px;">
                        Last updated: ${new Date().toLocaleTimeString()}
                    </div>
                `;
            }
        }

        // Add this function to your code
        function announcePresenceAndRequestOffer() {
            console.log('Announcing presence and requesting offer from room creator');
            
            // Send a direct request for an offer
            sendSignalingMessage({
                type: 'request-offer',
                message: 'New participant requesting offer'
            });
            
            // Set up a timer to retry if we don't get a response
            window.requestOfferInterval = setInterval(() => {
                if (peerConnection.iceConnectionState === 'new') {
                    console.log('Still waiting for offer, sending another request');
                    sendSignalingMessage({
                        type: 'request-offer',
                        message: 'New participant requesting offer (retry)'
                    });
                } else {
                    console.log('Connection in progress or established, stopping request interval');
                    clearInterval(window.requestOfferInterval);
                }
            }, 3000); // Retry every 3 seconds
        }

        // Add this function to handle ending the meeting
        function endMeeting() {
            console.log('Ending meeting...');
            
            // Stop gesture recognition
            stopGestureRecognition();
            
            // Close peer connection if it exists
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Stop all tracks in the local stream
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                });
                localStream = null;
            }
            
            // Clear the video elements
            document.getElementById('localVideo').srcObject = null;
            document.getElementById('remoteVideo').srcObject = null;
            
            // Disconnect from Scaledrone
            if (window.signalingDrone) {
                window.signalingDrone.close();
            }
            
            // Clear any intervals
            if (window.requestOfferInterval) clearInterval(window.requestOfferInterval);
            if (window.offerInterval) clearInterval(window.offerInterval);
            if (window.checkForIceCandidates) clearInterval(window.checkForIceCandidates);
            if (window.frameDetectionInterval) clearInterval(window.frameDetectionInterval);
            
            // Reset room ID
            currentRoomId = null;
            
            // Update UI to show meeting ended
            document.getElementById('roomInfo').innerHTML = `
                <div class="room-details">
                    <h3>Meeting Ended</h3>
                    <p>You have left the meeting.</p>
                    <button onclick="window.location.reload()" style="background: #28a745;">Start New Meeting</button>
                </div>
            `;
        }

        // Add this function to share detected gestures
        function shareGestureDetection(gesture) {
            // Only share if we have a connection and a gesture
            if (peerConnection && peerConnection.iceConnectionState === 'connected' && gesture) {
                console.log('Sharing gesture detection with peer:', gesture);
                
                // Send the gesture via Scaledrone
                sendSignalingMessage({
                    type: 'gesture-detected',
                    gesture: gesture
                });
            }
        }

        // Add this function to perform client-side gesture recognition as a fallback
        function performClientSideGestureRecognition(videoElement, translationElement) {
            // This is a simplified version that just cycles through gestures for demonstration
            // In a real implementation, you would use a client-side ML model
            
            const gestures = [
                "Hello", "Small", "Super", "Luck", "Love", 
                "Victory", "Call me", "Prosper", "Power", "Home"
            ];
            
            let gestureIndex = 0;
            
            // Set up a timer to simulate gesture recognition
            const fallbackInterval = setInterval(() => {
                // Only show gestures occasionally to simulate real recognition
                if (Math.random() < 0.2) { // 20% chance of detecting a gesture
                    const gesture = gestures[gestureIndex];
                    gestureIndex = (gestureIndex + 1) % gestures.length;
                    
                    // Display the gesture
                    translationElement.textContent = gesture;
                    translationElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    translationElement.style.color = 'white';
                    translationElement.style.padding = '10px 20px';
                    translationElement.style.borderRadius = '4px';
                    translationElement.style.fontSize = '24px';
                    translationElement.style.fontWeight = 'bold';
                    translationElement.style.border = '2px solid #FF9800'; // Different color for fallback
                    
                    // Clear after 3 seconds
                    setTimeout(() => {
                        translationElement.textContent = '';
                        translationElement.style.border = 'none';
                    }, 3000);
                    
                    // Share with remote participant
                    shareGestureDetection(gesture);
                    
                    // Add to history
                    addGestureToHistory({
                        userId: socket.id,
                        gesture: { translation: gesture },
                        timestamp: Date.now()
                    });
                }
            }, 5000); // Check every 5 seconds
            
            // Store the interval ID for cleanup
            window.fallbackGestureInterval = fallbackInterval;
        }

        // Update the performGestureRecognition function to include fallback
        function performGestureRecognition(videoElement, translationElement) {
            // Create a canvas to capture video frames
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            console.log('Starting gesture recognition on video element');
            
            // Set up the recognition interval
            const recognitionInterval = setInterval(() => {
                // Check if the video is playing and the peer connection is established
                if (videoElement.paused || videoElement.ended || !videoElement.videoWidth) {
                    return;
                }
                
                // Resize canvas to match video dimensions
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                
                // Draw the current video frame to the canvas
                ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                
                // Get the image data from the canvas
                const imageData = canvas.toDataURL('image/jpeg', 0.7);
                
                // Send the frame for server-side gesture recognition
                if (socket.connected) {
                    socket.emit('recognize-gesture', {
                        frame: imageData,
                        roomId: currentRoomId
                    });
                } else {
                    console.log('Socket not connected, cannot send frame for recognition');
                    
                    // If we haven't started the fallback yet, start it now
                    if (!window.fallbackGestureInterval) {
                        console.log('Starting fallback gesture recognition');
                        performClientSideGestureRecognition(videoElement, translationElement);
                    }
                }
            }, 300); // Process every 300ms to balance responsiveness and performance
            
            // Store the interval ID for cleanup
            window.gestureRecognitionInterval = recognitionInterval;
            
            console.log('Gesture recognition started');
        }

        // Update the stopGestureRecognition function to also stop the fallback
        function stopGestureRecognition() {
            if (window.gestureRecognitionInterval) {
                clearInterval(window.gestureRecognitionInterval);
                window.gestureRecognitionInterval = null;
            }
            
            if (window.fallbackGestureInterval) {
                clearInterval(window.fallbackGestureInterval);
                window.fallbackGestureInterval = null;
            }
        }

        // Update the socket event handler for gesture recognition results
        socket.on('gesture-recognition-result', data => {
            console.log('Received gesture recognition result:', data);
            
            // Display the recognized gesture
            if (data.gesture) {
                const translationElement = document.getElementById('localTranslation');
                
                // Apply styling to make the gesture name more visible
                translationElement.textContent = data.gesture;
                translationElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                translationElement.style.color = 'white';
                translationElement.style.padding = '10px 20px';
                translationElement.style.borderRadius = '4px';
                translationElement.style.fontSize = '24px'; // Increased font size
                translationElement.style.fontWeight = 'bold';
                
                // Add a visual indicator that this is a recognized gesture
                translationElement.style.border = '2px solid #4CAF50';
                
                // Share the gesture with the other participant
                shareGestureDetection(data.gesture);
                
                // Clear the text after 3 seconds
                setTimeout(() => {
                    translationElement.textContent = '';
                    translationElement.style.border = 'none';
                }, 3000);
                
                // Add to gesture history
                addGestureToHistory({
                    userId: socket.id,
                    gesture: { translation: data.gesture },
                    timestamp: Date.now()
                });
                
                // Play a sound to indicate gesture recognition (optional)
                playRecognitionSound();
            }
        });

        // Add this function to play a sound when a gesture is recognized
        function playRecognitionSound() {
            // Create a simple beep sound
            const context = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(context.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.value = 800;
            gainNode.gain.value = 0.1;
            
            oscillator.start(0);
            
            // Stop the sound after 200ms
            setTimeout(() => {
                oscillator.stop();
            }, 200);
        }

        // Update the displayRemoteGesture function
        function displayRemoteGesture(gesture) {
            const remoteTranslation = document.getElementById('remoteTranslation');
            if (remoteTranslation) {
                // Apply styling to make the gesture name more visible
                remoteTranslation.textContent = gesture;
                remoteTranslation.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                remoteTranslation.style.color = 'white';
                remoteTranslation.style.padding = '10px 20px';
                remoteTranslation.style.borderRadius = '4px';
                remoteTranslation.style.fontSize = '24px'; // Increased font size
                remoteTranslation.style.fontWeight = 'bold';
                remoteTranslation.style.border = '2px solid #2196F3'; // Different color for remote gestures
                
                // Clear the text after 3 seconds
                setTimeout(() => {
                    remoteTranslation.textContent = '';
                    remoteTranslation.style.border = 'none';
                }, 3000);
                
                // Add to gesture history
                addGestureToHistory({
                    userId: 'remote',
                    gesture: { translation: gesture },
                    timestamp: Date.now()
                });
                
                // Play a different sound for remote gestures (optional)
                playRemoteGestureSound();
            }
        }

        // Add this function to play a sound when a remote gesture is received
        function playRemoteGestureSound() {
            const context = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(context.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.value = 600; // Different frequency for remote gestures
            gainNode.gain.value = 0.1;
            
            oscillator.start(0);
            
            setTimeout(() => {
                oscillator.stop();
            }, 200);
        }

        // Add this debugging function
        function debugGestureRecognition() {
            console.log('Debugging gesture recognition:');
            console.log('- Socket connected:', socket.connected);
            console.log('- Current room ID:', currentRoomId);
            console.log('- Local video ready:', document.getElementById('localVideo').readyState);
            console.log('- Remote video ready:', document.getElementById('remoteVideo').readyState);
            console.log('- Gesture recognition interval active:', window.gestureRecognitionInterval !== undefined);
            
            // Test socket connection
            if (socket.connected) {
                socket.emit('test-gesture-recognition', {}, (response) => {
                    console.log('Gesture recognition test response:', response);
                });
            }
        }

        // Add a button to trigger debugging
        document.getElementById('roomInfo').innerHTML += `
            <div style="margin-top: 10px;">
                <button onclick="debugGestureRecognition()" style="background: #6c757d;">
                    Debug Gesture Recognition
                </button>
            </div>
        `;

        // Add this socket event handler for testing
        socket.on('test-gesture-recognition-response', (data) => {
            console.log('Received test gesture recognition response:', data);
            alert('Gesture recognition test: ' + (data.success ? 'Successful' : 'Failed'));
        });

        // Add this function to restart gesture recognition
        function restartGestureRecognition() {
            console.log('Restarting gesture recognition');
            
            // Stop current recognition
            stopGestureRecognition();
            
            // Start recognition again
            performGestureRecognition(document.getElementById('localVideo'), document.getElementById('localTranslation'));
            
            // Show confirmation
            alert('Gesture recognition restarted');
        }

        // Add this function to the end of your script
        function addManualGestureControls() {
            // Create a container for the manual controls
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'manual-gesture-controls';
            controlsContainer.style.marginTop = '20px';
            controlsContainer.style.padding = '15px';
            controlsContainer.style.backgroundColor = 'white';
            controlsContainer.style.borderRadius = '8px';
            controlsContainer.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
            
            // Add a title
            const title = document.createElement('h3');
            title.textContent = 'Manual Gesture Display';
            controlsContainer.appendChild(title);
            
            // Add a description
            const description = document.createElement('p');
            description.textContent = 'If automatic gesture recognition is not working, you can manually display gestures:';
            controlsContainer.appendChild(description);
            
            // Create a grid for gesture buttons
            const buttonGrid = document.createElement('div');
            buttonGrid.style.display = 'grid';
            buttonGrid.style.gridTemplateColumns = 'repeat(5, 1fr)';
            buttonGrid.style.gap = '10px';
            buttonGrid.style.marginTop = '10px';
            
            // Add buttons for each gesture
            const gestures = [
                "Hello", "Small", "Super", "Luck", "Love", 
                "Victory", "Call me", "Prosper", "Power", "Home"
            ];
            
            gestures.forEach(gesture => {
                const button = document.createElement('button');
                button.textContent = gesture;
                button.style.padding = '8px';
                button.style.backgroundColor = '#007bff';
                button.style.color = 'white';
                button.style.border = 'none';
                button.style.borderRadius = '4px';
                button.style.cursor = 'pointer';
                
                button.addEventListener('click', () => {
                    // Display the gesture
                    const translationElement = document.getElementById('localTranslation');
                    translationElement.textContent = gesture;
                    translationElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    translationElement.style.color = 'white';
                    translationElement.style.padding = '10px 20px';
                    translationElement.style.borderRadius = '4px';
                    translationElement.style.fontSize = '24px';
                    translationElement.style.fontWeight = 'bold';
                    translationElement.style.border = '2px solid #9C27B0'; // Different color for manual gestures
                    
                    // Clear after 3 seconds
                    setTimeout(() => {
                        translationElement.textContent = '';
                        translationElement.style.border = 'none';
                    }, 3000);
                    
                    // Share with remote participant
                    shareGestureDetection(gesture);
                    
                    // Add to history
                    addGestureToHistory({
                        userId: socket.id,
                        gesture: { translation: gesture },
                        timestamp: Date.now()
                    });
                });
                
                buttonGrid.appendChild(button);
            });
            
            controlsContainer.appendChild(buttonGrid);
            
            // Add the controls to the page
            document.querySelector('.container').appendChild(controlsContainer);
        }

        // Call this function when the connection is established
        function onConnectionEstablished() {
            // Add manual gesture controls
            addManualGestureControls();
            
            // Start automatic gesture recognition
            performGestureRecognition(document.getElementById('localVideo'), document.getElementById('localTranslation'));
        }
    </script>
</body>
</html> 
